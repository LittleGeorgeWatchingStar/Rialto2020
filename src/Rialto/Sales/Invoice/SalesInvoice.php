<?php

namespace Rialto\Sales\Invoice;

use DateTime;
use InvalidArgumentException;
use Rialto\Accounting\Card\CapturableInvoice;
use Rialto\Accounting\Debtor\DebtorInvoice;
use Rialto\Accounting\Debtor\DebtorTransaction;
use Rialto\Accounting\Ledger\Account\GLAccount;
use Rialto\Accounting\Money;
use Rialto\Accounting\Transaction\SystemType;
use Rialto\Accounting\Transaction\Transaction;
use Rialto\Company\Company;
use Rialto\Database\Orm\DbManager;
use Rialto\Sales\Order\SalesOrder;
use Rialto\Sales\Order\SalesOrderDetail;
use Rialto\Sales\Order\TaxableOrder;
use Rialto\Sales\Price\PriceCalculator;
use Rialto\Sales\Shipping\ShippableOrder;
use Rialto\Sales\Type\SalesType;
use Rialto\Shipping\Export\DeniedPartyException;
use Rialto\Shipping\Export\DeniedPartyScreener;
use Rialto\Shipping\Method\ShippingMethodInterface as ShippingMethodInterface;
use Rialto\Shipping\Shipment\ShipmentPackage;
use Rialto\Stock\Sku;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\Validator\Context\ExecutionContextInterface;

/**
 * An invoice for a sales order.
 *
 * An invoice looks a lot like a regular sales order (so much so that they
 * both implement ISalesOrder).  However, you might only invoice part of the
 * entire order at a given time, so this class allows you to set line item
 * quantities that are different from those of the parent sales order.
 */
class SalesInvoice implements
    ShippableOrder,
    TaxableOrder,
    CapturableInvoice
{
    /**
     * @Assert\Valid
     * @var SalesOrder
     */
    private $salesOrder;

    /**
     * @Assert\Valid(traverse="true")
     * @var SalesInvoiceItem[]
     */
    private $lineItems = [];

    /** @var ShippingMethodInterface */
    private $shippingMethod;

    /**
     * @Assert\Type(type="float", message="Shipping price must be a {{ type }}.")
     */
    private $shippingPrice;

    /**
     * For some shippers, we need to put the tracking number into this
     * field manually.
     *
     * For others (eg, UPS), the tracking number is generated by the API,
     * in which case this field is not used.
     * @var string
     */
    private $trackingNumber = '';

    /**
     * @var ShipmentPackage[]
     * @Assert\Valid(traverse=true)
     */
    private $packages = [];
    private $dispatchDate;
    private $comments = '';
    private $closeOrder = false;
    private $invoiceNo = null;

    /** @var DeniedPartyScreener */
    private $deniedPartyScreener = null;

    /** @var DebtorInvoice */
    private $debtorTrans = null;

    public function __construct(SalesOrder $order)
    {
        if ($order->isQuotation()) {
            throw new InvalidArgumentException('Cannot invoice a quotation');
        }
        if ($order->isCompleted()) {
            throw new InvalidArgumentException('Cannot invoice a completed sales order');
        }
        $this->salesOrder = $order;

        $this->shippingPrice = $this->salesOrder->getShippingPrice() -
            $this->salesOrder->getAmountInvoicedForShipping();
        if ($this->shippingPrice < 0) {
            $this->shippingPrice = 0;
        }
        $this->dispatchDate = new DateTime();
        $this->shippingMethod = $order->getShippingMethod();

        $this->comments = $order->getComments();

        foreach ($order->getLineItems() as $soDetail) {
            $this->addLineItem($soDetail);
        }

        $this->packages[] = new ShipmentPackage($this->getCalculatedWeight());
    }

    public function setDeniedPartyScreener(DeniedPartyScreener $screener)
    {
        $this->deniedPartyScreener = $screener;
    }

    /** @Assert\Callback */
    public function validateRecipient(ExecutionContextInterface $context)
    {
        if ($this->salesOrder->isDueToShip()) {
            return;
        }
        if (!$this->deniedPartyScreener) {
            return;
        }
        if (!$this->deniedPartyScreener->isEnabled()) {
            return;
        }

        try {
            $response = $this->deniedPartyScreener->screen($this);
            if ($response->hasDeniedParties()) {
                $deniedParties = $response->getMatchingParties();
                $message = 'The recipient of this order matches the following denied parties:';
                foreach ($deniedParties as $party) {
                    $message .= ' ' . $party;
                }
                $context->addViolation($message);
            }
        } catch (DeniedPartyException $ex) {
            $context->addViolation($ex->getMessage());
        }
    }

    /**
     * @Assert\NotBlank(message="Branch email address is missing.")
     * @Assert\Email(message="Branch email address is not valid.")
     */
    public function getBranchEmail()
    {
        return $this->salesOrder->getCustomerBranch()->getEmail();
    }

    /** @return SalesOrder */
    public function getSalesOrder()
    {
        return $this->salesOrder;
    }

    public function __toString()
    {
        return "invoice for " . $this->salesOrder;
    }

    /**
     * Creates a new line item, adds it to this invoice, and returns it.
     *
     * @param SalesOrderDetail $item
     * @param int|float $quantity
     * @return SalesInvoiceItem
     */
    private function addLineItem(SalesOrderDetail $item)
    {
        $invItem = new SalesInvoiceItem($this, $item);
        $this->lineItems[] = $invItem;
        return $invItem;
    }

    /**
     * @return SalesInvoiceItem[]
     */
    public function getLineItems()
    {
        return $this->lineItems;
    }

    /**
     * @return SalesInvoiceItem[]
     */
    public function getTangibleLineItems()
    {
        return array_filter($this->getLineItems(), function (SalesInvoiceItem $lineItem) {
            return !Sku::isServiceFee($lineItem->getSku());
        });
    }

    public function setLineItems(array $items)
    {
        $this->lineItems = $items;
    }

    /** @Assert\Callback */
    public function validateSomethingSelected(ExecutionContextInterface $context)
    {
        foreach ($this->lineItems as $item) {
            if ($item->getQtyToShip() > 0) {
                return;
            }
        }
        $context->addViolation("No items selected to invoice.");
    }

    /**
     * Returns the prepaid amount that can be applied to this invoice.
     *
     * @return float
     */
    public function getPrepaidAmount()
    {
        $invoiceTotal = $this->salesOrder->getTotalAmountInvoiced();
        $receiptTotal = $this->salesOrder->getTotalAmountPaid();
        $prepaid = max($receiptTotal - $invoiceTotal, 0);
        return min($prepaid, $this->getTotalPrice());
    }

    /**
     * @return float The dollar amount to capture if paying by credit card.
     */
    public function getAmountToCapture()
    {
        $prepaid = $this->getPrepaidAmount();

        $cardAuth = $this->salesOrder->getCardAuthorization();
        $authorized = $cardAuth ? $cardAuth->getAmountAuthorized() : 0;

        $outstanding = Money::round($this->getTotalPrice() - $prepaid);
        $toCapture = min($authorized, $outstanding);
        return max($toCapture, 0);
    }

    /**
     * Calculates the total weight of all of the line items in this invoice.
     *
     * @return float
     */
    public function getCalculatedWeight()
    {
        $total = 0;
        foreach ($this->lineItems as $item) {
            $total += $item->getTotalWeight();
        }
        return $total;
    }

    public function getComments()
    {
        return $this->comments;
    }

    /**
     * @return float
     */
    public function getCurrencyRate()
    {
        return $this->salesOrder->getCurrencyRate();
    }

    public function getCustomer()
    {
        return $this->salesOrder->getCustomer();
    }

    public function getCompanyName()
    {
        return $this->salesOrder->getCompanyName();
    }

    public function getContactName()
    {
        return $this->salesOrder->getContactName();
    }

    public function getBillingCompany()
    {
        return $this->salesOrder->getBillingCompany();
    }

    public function getBillingName()
    {
        return $this->salesOrder->getBillingName();
    }

    public function getBillingAddress()
    {
        return $this->salesOrder->getBillingAddress();
    }

    public function getCustomerBranch()
    {
        return $this->salesOrder->getCustomerBranch();
    }

    public function getCustomerReference(): string
    {
        return $this->salesOrder->getCustomerReference();
    }

    public function getCustomerTaxId()
    {
        return $this->salesOrder->getCustomerTaxId();
    }

    public function getDeliveryCompany()
    {
        return $this->salesOrder->getDeliveryCompany();
    }

    public function getDeliveryName()
    {
        return $this->salesOrder->getDeliveryName();
    }

    public function getDeliveryAddress()
    {
        return $this->salesOrder->getDeliveryAddress();
    }

    public function getDispatchDate()
    {
        return $this->dispatchDate;
    }

    public function getInvoiceNumber()
    {
        return $this->invoiceNo;
    }

    public function getOrderNumber()
    {
        return $this->salesOrder->getOrderNumber();
    }

    /**
     * @return int The source ID of the sales order.
     */
    public function getSourceId()
    {
        return $this->salesOrder->getSourceId();
    }

    public function getContactPhone()
    {
        return $this->salesOrder->getContactPhone();
    }

    /**
     * @return SalesType
     */
    public function getSalesType()
    {
        return $this->salesOrder->getSalesType();
    }

    public function getShipper()
    {
        return $this->salesOrder->getShipper();
    }

    /** @Assert\Callback */
    public function validateShipper(ExecutionContextInterface $context)
    {
        if (!$this->containsShippableItems()) {
            return;
        }
        if (!$this->getShipper()) {
            $context->addViolation('No shipper selected.');
        }
    }

    /**
     * @return ShippingMethodInterface
     */
    public function getShippingMethod()
    {
        return $this->shippingMethod;
    }

    /** @Assert\Callback */
    public function validateShippingMethod(ExecutionContextInterface $context)
    {
        if (!$this->containsShippableItems()) {
            return;
        }
        if (!$this->shippingMethod) {
            $context->buildViolation('No shipping method selected.')
                ->atPath('shippingMethod')
                ->addViolation();
        }
    }

    /** @Assert\Callback */
    public function validateOrderCanShip(ExecutionContextInterface $context)
    {
        if ($this->salesOrder->doNotShip()) {
            $reason = $this->salesOrder->getReasonNotToShip();
            $message = "Order is not approved for shipping. Reason: $reason";
            $context->buildViolation($message)
                ->setCode('shipping')
                ->addViolation();
        }
    }

    public function getShippingPrice()
    {
        return $this->shippingPrice;
    }

    /**
     * True if the tracking number must be entered manually.
     *
     * This is false when the tracking number is generated automatically
     * via the shipper's API.
     * @return boolean
     */
    public function isTrackingNumberRequired()
    {
        return $this->shippingMethod ?
            $this->shippingMethod->isTrackingNumberRequired() : false;
    }

    public function getTrackingNumber()
    {
        return $this->trackingNumber;
    }

    public function setTrackingNumber($trackingNumber)
    {
        $this->trackingNumber = trim($trackingNumber);
    }

    /** @Assert\Callback */
    public function validateTrackingNumber(ExecutionContextInterface $context)
    {
        if ($this->isTrackingNumberRequired() && (!$this->trackingNumber)) {
            $context->buildViolation(
                "A tracking number is required for shipping method \"{$this->shippingMethod}\".")
                ->atPath('trackingNumber')
                ->addViolation();
        }
    }

    public function getSubtotalPrice()
    {
        $total = 0;
        foreach ($this->lineItems as $item) {
            $total += $item->getExtendedPrice();
        }
        return $total;
    }

    public function getSubtotalValue()
    {
        $total = 0;
        foreach ($this->getTangibleLineItems() as $item) {
            $total += $item->getExtendedValue();
        }
        return $total;
    }

    public function getTaxAmount()
    {
        $calculator = new PriceCalculator();
        return $calculator->calculateTaxAmount($this);
    }

    public function getTangibleTaxAmount()
    {
        $calculator = new PriceCalculator();
        $tangibleItems = $this->getTangibleLineItems();
        $shippingPrice = $this->getShippingPrice();
        return $calculator->calculateItemsTaxAmount($tangibleItems, $shippingPrice);
    }

    /**
     * @Assert\Range(max=50000, maxMessage="Cannot ship more than ${{ limit }} at a time.")
     */
    public function getTotalPrice()
    {
        return $this->getSubtotalPrice() +
            $this->shippingPrice +
            $this->getTaxAmount();
    }

    /**
     * @Assert\Range(max=50000, maxMessage="Cannot ship more than ${{ limit }} at a time.")
     */
    public function getTotalTangibleValue()
    {
        return $this->getSubtotalValue() +
            $this->shippingPrice +
            $this->getTangibleTaxAmount();
    }

    public function getTotalWeight()
    {
        $total = 0;
        foreach ($this->packages as $pkg) {
            $total += $pkg->getWeight();
        }
        return $total;
    }

    public function containsShippableItems()
    {
        return $this->salesOrder->containsShippableItems();
    }

    public function getReasonForShipping()
    {
        return $this->salesOrder->getReasonForShipping();
    }

    public function isOverdue()
    {
        $due = $this->salesOrder->getDeliveryDate();
        if (!$due) {
            return false;
        }
        return $due < $this->dispatchDate;
    }

    public function setCloseOrder($bool)
    {
        $this->closeOrder = $bool;
        return $this;
    }

    public function isCloseOrder()
    {
        return $this->closeOrder;
    }

    public function setComments($comments)
    {
        $this->comments = $comments;
        return $this;
    }

    public function setDispatchDate(DateTime $date)
    {
        $this->dispatchDate = $date;
        return $this;
    }

    public function setShippingMethod(ShippingMethodInterface $method = null)
    {
        if (null !== $method) {
            $method = $this->getShipper()->getShippingMethod($method->getCode());
        }
        $this->shippingMethod = $method;
        return $this;
    }

    public function setShippingPrice($price)
    {
        $this->shippingPrice = $price;
        return $this;
    }

    public function getPackages()
    {
        return $this->packages;
    }

    public function setPackages(array $packages)
    {
        $this->packages = $packages;
    }


    /**
     * Processes this invoice, creating accounting records and consuming the
     * stock.
     *
     * @return DebtorInvoice
     */
    public function process(DbManager $dbm)
    {
        $invoiceType = SystemType::fetchSalesInvoice($dbm);
        $glTrans = new Transaction($invoiceType);
        $glTrans->setMemo($this->getOrderNumber());
        $glTrans->setDate($this->dispatchDate);
        $this->invoiceNo = $glTrans->getSystemTypeNumber();

        /* We have to calculate the prepaid amount BEFORE we create a
         * new invoice for this transaction, because invoices affect
         * the calculation of prepaid amount. */
        $prepaidAmount = $this->getPrepaidAmount();

        /* Now create a new invoice. */
        $this->debtorTrans = new DebtorInvoice($glTrans, $this->salesOrder);
        $this->debtorTrans->setMemo($this->comments)
            ->setSubtotalAmount($this->getSubtotalPrice())
            ->setTaxAmount($this->getTaxAmount())
            ->setShipper($this->getShipper())
            ->setShippingAmount($this->shippingPrice);
        $dbm->persist($this->debtorTrans);

        foreach ($this->lineItems as $item) {
            $item->setCloseOrder($this->closeOrder);
            $item->process($this->debtorTrans, $glTrans);
            if ($item->getQtyToShip() > 0) {
                $item->recordGLEntries($glTrans);
            }
        }

        $this->recordGLEntries($glTrans, $prepaidAmount);
        $dbm->persist($glTrans);

        $this->allocateInvoiceAgainstPayments($this->debtorTrans);

        return $this->debtorTrans;
    }

    /** @return DebtorTransaction */
    public function getDebtorTransaction()
    {
        return $this->debtorTrans;
    }

    private function recordGLEntries(Transaction $glTrans, $prepaidAmount)
    {
        $transactionTotal = $this->getTotalPrice();
        $unpaidAmount = round($transactionTotal - $prepaidAmount, 2);

        $company = Company::fetchDefault();
        $customer = $this->getCustomer();
        $memo = $customer->getId(); /* narrative is just customer id */
        if ($unpaidAmount) {
            $debtorAccount = $company->getDebtorAccount();
            $glTrans->addEntry(
                $debtorAccount,
                $unpaidAmount,
                $memo
            );
        }
        if ($prepaidAmount) {
            $prepaidAccount = GLAccount::fetchPrepaidRevenue();
            $glTrans->addEntry(
                $prepaidAccount,
                $prepaidAmount,
                $memo
            );
        }

        if ($this->shippingPrice != 0) {
            $shippingAccount = $company->getShippingAccount();
            $glTrans->addEntry(
                $shippingAccount,
                -$this->shippingPrice,
                $memo
            );
        }

        if ($this->getTaxAmount() != 0) {
            $branch = $this->getCustomerBranch();
            $taxAuthority = $branch->getTaxAuthority();
            $glTrans->addEntry(
                $taxAuthority->getAccount(),
                -$this->getTaxAmount(),
                $memo
            );
        }
    }

    private function allocateInvoiceAgainstPayments(
        DebtorInvoice $debtorTrans)
    {
        $remaining = $debtorTrans->getAmountUnallocated();
        foreach ($this->salesOrder->getCreditAllocations() as $alloc) {
            if ($remaining <= 0) {
                break;
            }
            $toAllocate = min($alloc->getAmount(), $remaining);
            if ($toAllocate <= 0) {
                continue;
            }
            $debtorTrans->allocateFrom($alloc->getCredit(), $toAllocate);
            $remaining -= $toAllocate;
        }
    }

    public function shipperPaysDuties()
    {
        return $this->salesOrder->shipperPaysDuties();
    }
}
